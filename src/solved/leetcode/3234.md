# 3234. [Count the Number of Substrings With Dominant Ones](./3234.cpp)

아 문제 진짜 더럽게 어렵네 이게 뭔 미디엄이야

각 지점마다 $0$과 $1$의 누적 개수를 센다. 각 substring마다 0과 1의 개수를 상수 시간에 계산하기 위함이다.

이제 모든 substring에 대해서, dominant한 substring에 포함될 수 있는 $0$의 최대 개수를 확인한다. 이는 early break에 사용된다.

메인 루프는 $left = 0 \ldots N - 1$에 대해 모든 $right$를 탐색하면서 각 substring이 dominant한지 확인한다. 소모 시간을 최대한 줄이기 위해 다음과 같은 트릭을 사용한다.

현재 탐색중인 substring의 $1$과 $0$의 개수를 각각 $cnt\_one, cnt\_zero$라고 하자.

탐색 중에, $cnt\_ zero \gt max\_ zero$면 탐색을 조기 종료한다. 등호의 여부는 크게 상관없으나, 안전하게 $\gt$로 잡았다.

만약 현재 substring이 dominant하다면 $0$을 최대 $\sqrt{cnt\_ one} - cnt\_ zero$만큼 추가할 수 있다. 따라서 $\sqrt{cnt\_ one} - cnt\_ zero$ 만큼 $right$를 전진시킬 수 있고, 이 구간의 $right$에 해당하는 substring은 전부 dominant한 substring이 된다.

반대로 현재 substring이 dominant하지 않다면 $1$을 최소 $cnt\_ zero^2 - cnt\_ one$만큼 증가시켜야 하며, 이만큼 증가시키는 동안에는 모든 substring이 dominant하지 않은 것을 알 수 있다.

```cpp
if (one >= zero * zero) {
    cnt = std::clamp(sqrt(one) - zero + 1, 0,
                        as<int32_t>(n - right));
    ret += cnt;
} else {
    cnt = (zero * zero) - one;
}
```

현재 문자열을 cnt에 추가해야 하기 때문에 $+1$이 붙는다.

시간 복잡도는 내부의 early break 때문에 $O(N^{1.5})$가 나온다.
