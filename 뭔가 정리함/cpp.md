# C++ 관련하여 생각해볼만한 것들

[이 글](https://blog.mcdic.net/series/cpp/4/)을 읽고 좀 충격받았다. 나는 정말 C++에 대해 아무것도 모른다.

## 프로그램 실행시 사용되는 메모리 영역의 구분

메모리는 낮은 주소부터 순서대로 텍스트, 데이터, 힙, 스택으로 나뉜다.

### 텍스트

프로그램의 명령문, 상수, 제어문, 함수 등이 저장된다. OS는 이 곳에서 코드를 하나씩 뽑아서 실행한다.

읽기 전용 특성을 가지며, 여러 프로세스가 동일한 프로그램을 실행할 때 텍스트 영역을 공유할 수 있다. 또한 텍스트 영역은 크기가 컴파일 타임에 결정되고, CPU 명령어 캐시에 저장되는 편이다.

### 데이터

전역 변수와 정적 변수 등을 저장한다. 통상적으로 main 이전에 선언되어 프로그램 실행부터 종료까지 메모리에 상주한다.

이 중에서도 초기화된 initialized data segment와 초기화되지 않고 0으로 fill 된 block started by symbol이라는 두 개의 영역으로 나뉜다.

### 힙

사용자가 관리하는 영역이다. 흔히 쓰는 동적 메모리 할당이 여기에 이루어진다. 관련하여 힙 메모리 파편화, 메모리 풀, 가비지 컬렉터 등의 주제가 나올 수 있다.

메모리 풀은 가능할만한 최대 크기로 할당을 처음부터 받아버리는 것.

가비지 컬렉터는 Mark & Compact 전략을 사용하는데, 이는 자원을 마킹하면서 안 쓰는 것들을 다른 영역으로 복사하면서 compact 하게 만드는 과정을 수행하고 큰 힙 영역을 확보하는 것을 골자로 한다.

참고로 스택과 힙 사이에는 빈 공간이 있고 보통 힙이 낮은 주소에서 시작해서 높은 주소로 간다. 스택은 반대로.

### 스택

보통 1MB 정도의 최대 크기를 갖는다. 여기부터는 굉장히 CS 적인 지식이 많이 필요한데, 우선 스택에 뭐가 들어가는가? 부터 보자.

스택에는 함수 콜스택이 쌓인다. 그래서 각 스택별로 시작점과 끝점이 필요하고, 각 함수 스택마다 해당 함수 내에서 사용되는 지역 변수들이 생긴다. 큰 메모리가 필요하면 보통 힙에 할당하고 그 주소값을 가져온다.

정확히는, 스택에 들어갈 수 있는 것은 사이즈가 명확한 것들이다. 그래서 동적 할당이 안되는거다. 잘 생각해보면 스택의 시작점과 끝점이 정의가 되어있어야 스택의 구성 요소들이 분리가 될텐데, 사이즈가 변동된다면? 끝점의 의미가 없어지고, 이 말은 스택의 다음 위치에 있는 놈의 시작점 위치가 이상해진다는 것.

스택 프레임에 대한 이야기도 빼놓을 수 없다. 스택 프레임은 다음 네 개의 요소를 가진다.

반환 주소, 매개변수, 지역 변수, 레지스터 값들.

반환 주소: 이 스택 프레임의 함수 호출이 끝난 후 돌아갈 주소이다.

매개변수: 함수 호출 시 전달된 인자들이다.

지역 변수: 함수 내부에서 선언된 지역 변수들이다.

레지스터 값: 함수 호출 전의 상태를 복원하기 위해 함수를 호출한 시점에서의 레지스터 변수들이다. 프로그램의 흐름이 끊기지 않도록 해주는 역할이다.

## Move semantic

이 코드를 실행하면 move는 얼마나 발생하고 copy는 얼마나 발생할까? 라는 주제인데... 이건 잘 모른다...

lvalue와 rvalue, reference 관련해서 지식이 좀 필요할 것 같다...

## virtual 함수가 일반 함수와 다른 점, 그리고 그 구현을 어떻게 할까?

일단 가상함수는 클래스에서 반드시 재정의되기를 바라는 함수다. = 0;이 붙으면 pure virtual 이 된다. 얘는 직접 호출되면 안된다. 그래서 이게 포함된 클래스는 abstract class가 된다.

보통 virtual 함수가 있으면 컴파일러는 vtable을 생성해서 해당 클래스에서 구현된 함수 포인터들을 저장한다. 그리고 호출되면 그 함수들로 가는 것.
