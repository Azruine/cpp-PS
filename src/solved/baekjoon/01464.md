# 01464. [뒤집기 3](./01464.cpp)

신기한 문제였다.

"BCDAF" 예제를 보면서 풀이를 생각해보자. XXOOX 순서대로 진행하면 "ABCDF"가 나온다고 한다.

맨 처음, B는 그냥 넣는다. 다음, C를 넣고 싶다. 뒤집는다는 것을 잘 생각해보면, B의 앞에 C를 넣느냐 혹은 뒤에 C를 넣느냐 두 가지로 나뉜다.

여기서 이 문제의 특이한 점이 나오는데, 그리디한 성질이 충족된다. 중간까지 사전순으로 제일 앞서는 답을 고르면 그게 최종 답의 일부가 된다. 왜 그런지는 뒤에서 알아보고, 일단 그렇다고 하고 넘어가자.

사전순으로 제일 앞서는 문자열을 만들고 싶으니 "BC"와 "CB"를 비교해서 사전순으로 앞서는 것을 고르면 된다. 전자가 앞서니, C는 B의 뒤에 붙인다.

이는 곧 C를 넣기 직전에 문자열을 """뒤집지 않은 것"""이다. D도 마찬가지 논지로 문자열의 뒤에 추가된다.

이제 A가 등판한다. 현재 문자열은 "BCD"이다. A는 B보다 사전순으로 앞선다. 따라서 A를 맨 앞에 추가해주고 싶다... 어떻게?

바로 "BCD"를 뒤집고, "DCBA"를 다시 뒤집는 것이다. 길이 3과 4에서 뒤집은 것이 바로 A를 B보다 앞에 붙여주기 위함인 것이다.

만약 두 문자를 연달아 앞에 붙여주고 싶다면, 중간에 한 번 뒤집지 않으면 된다.

여기까지 왔으면, 이 문제가 왜 덱을 활용하는 문제인지 알 수 있다. 현재 추가하려는 문자가 현재 문자열의 앞보다 사전순으로 앞서면 앞에, 아니면 뒤에 추가하는 것이다.

이제 이 문제가 왜 그리디 속성을 만족하는지 간단히 알아보자.

일단 베이스 케이스는 문자열 하나짜리이다. 이건 자명하니 언급하지 않겠다.

이제 $i$ 번째 단계까지 적절한 선택으로 최적의 문자열 $res_i$를 만들었다고 가정하자. 아 머리 안 굴러간다