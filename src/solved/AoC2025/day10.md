# [10일차](day10.cpp)

아 시발 선대 진짜

파트 1은 xor 이고, 전구 개수가 10개 제한이라서 2^10 bfs로 가능하다.

파트 2는 전구의 전압이 최대 100까지 올라가는데, 이거 그대로 돌리면 바로 100^10 박힌다.

그래서 pruning을 해줘야 하는데, 좀 찾아보니 이게 [Integer Linear Programming](https://en.wikipedia.org/wiki/Integer_programming)이라는 유명한 NP 계열 문제라고 하더라.

근데 뭐 어쩌겠는가. 풀어야지. 일단 NP 문제를 정직하게 지수 복잡도로 풀라고 준 건 아닐테니, 입력을 살펴보았다.

앞서 말한대로 전구의 개수는 총 10개고, 버튼은 최대 13개, 목표값은 최대 99이다.

버튼에 영향받는 전구를 1로 표기한 행렬을 생각해보면 13행 10열 행렬이 되고, 자유 변수의 최대 개수는 13이다. 하지만 이 문제는 정말 다행히도 모든 입력에 대해 자유 변수를 3개까지로 제약을 걸어놓았다. 그게 문제에 직접 표기가 되어있지는 않지만... 결국 입력 분석해서 푼거라 좀 찝찝하긴 하다.

아무튼 자유 변수가 3개인 시점에서 대충 가닥이 잡힌다. 자유 변수를 전부 찾고, 나머지 변수들을 그 자유 변수로부터 구한다. 그런 다음, 변수들의 집합, 그러니까 버튼을 누른 횟수들이 전부 음이 아닌 정수인지 검사를 해보면 되는 것이다. 다음의 순서를 거쳐서 진행한다.

1. 가우스 조르당 소거
2. 자유 변수 찾기
3. 가능한 모든 조합 대입
4. 자유 변수들로 종속 변수를 표현하고, 모든 변수가 음이 아닌 정수이면 최소값에 기록

## 1. [가우스 조르당 소거](day10.cpp#274)

자유 변수를 찾기 위해서는 첨가 행렬에 대해 가우스 조르당 소거를 진행해야 한다. pivot은 1인게 계산이 편하므로, 유리수 구조체를 따로 만들어서 진행하는게 좋다.

가우스 말고 가우스 조르당으로 하는 이유는, 4에서 자유 변수만으로 종속 변수를 바로 구하기 위해서이다. 여기서 좀 귀찮은게 나중의 더 큰 귀찮음을 덜어낼 수 있다.

여기서 얻어갈 것은 RREF랑 pivot 위치, 랭크이다.

## 2. [자유 변수 찾기](day10.cpp#346)

RREF가 제대로 나왔으면, 여기선 그냥 pivot 위치만 체크하면 된다.

## 3. [가능한 모든 조합 대입](day10.cpp#363)

변수들 파라미터로 넘기기 싫어서 그냥 람다 재귀에 캡쳐를 썼다.

search 함수는 자유 변수 인덱스의 인덱스를 받는다. 그러니까 free_vars 벡터의 인덱스를 받는다는 뜻이다.

모든 자유 변수들에 대해, 재귀적으로 0부터 상한의 모든 조합을 대입한다.

## 4. [자유 변수들로 종속 변수를 표현](.day10.cpp#372)

val 에 종속 변수값을 저장하고, 음이 아닌 정수인지 검사한다.

답이 정상적이면 합을 best에 기록한다.
