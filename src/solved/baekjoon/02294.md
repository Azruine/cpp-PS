# 02294. 동전 2

개수 제한이 없는 동전 dp 문제다.

기본적인 아이디어는 대동소이하다. k 원을 맞추었을 때 최소 개수를 값으로 가지는 dp 배열을 선언하고, 하나씩 채우면 된다.

점화식에 대해 고민해보자.

일단 $dp_n = min(dp_(n - c) + 1, dp_n)$ 으로 생각할 수 있을 것 같다. 그런데 동전 개수에 제한이 없으니까 $c$원 동전을 무한대로 쓸 수 있다.

그래서 다음과 같이 루프가 하나 더 필요하다.

```cpp
for (auto &c : coin)
{
    int r = i / c;
    for (int x = 0; x <= r; x++)
    {
        dp[i] = std::min(dp[i], dp[i - x * c] + x);
    }
}
```

조심해야 할 것은 최소값이므로 보통 변수 범위의 최대값으로 초기화할텐데, 이러면 오버플로우가 나니까 조심해야 한다. 주어진 범위에 다르면 $10^7$ 정도로 최대값을 잡으면 오버플로우 없이도 안전하게 초기화되지 않았음을 체크할 수 있다.
