# 1792. [Maximum Average Pass Ratio](./1792.cpp)

평균값을 최대로 하면서 패스하는 학생을 추가하는 문제.

학생 한 명씩 추가하면서 비율이 제일 낮은 학급을 찾아야 하니 우선순위 큐를 썼다.

다시 데일리 문제로 나와서, 코드를 좀 바꿨다. 이번엔 벡터에 전부 넣어두고, std::make_heap, std::pop_heap, std::push_heap을 써봤다.

std::make_heap은 주어진 저장 공간을 heap으로 만든다, 즉, 맨 첫 원소가 priority_queue의 top이 된다. 시간 복잡도는 선형이며, 최대 $3N$ 만큼의 비교 연산을 진행한다.

std::push_heap은 주어진 저장 공간이 마지막 원소를 제외하고 heap으로 배열되어 있을 때 호출할 수 있다. heap의 push 연산인만큼 $log(N)$의 시간 복잡도를 가지며, 최대 $log(N)$번의 비교 연산을 진행한다.

std::pop_heap은 주어진 저장 공간이 heap 구조일 때, top의 원소를 제일 끝으로 보내고 top에 새로운 top 값을 올려준다. 최대 $2log(N)$번의 비교 연산을 진행한다.

ranges 네임스페이스의 함수들은 별거 없고, 그냥 컨테이너 던져주면 된다.

추가적으로 비교 연산을 정수 연산으로 변경했다. 큰 변화가 있...나?

코드를 변경하면서 몇 가지 시행착오가 있었다.

1. std::vector<int, int>의 오버헤드

    std::vector<std::vector<int, int>>를 직접 heapify해주었는데, 시간이 끔찍하게 오래 걸렸다. vector가 힙에 할당되어 있어서 그런 것으로 추정된다. std::vector<std::array<int, 2>>로 변경하자 속도가 0.5 배 수준으로 빨라졌다.

2. 람다 함수 선언 방식에 따른 차이

    std::function<>과 auto를 사용해서 비교자 람다를 선언할 때, std::function<>으로 선언한 것과 auto로 선언한 것끼리도 시간 차이가 꽤 많이 난다. 전자가 더 느린데, std::function은 함수를 힙에 처박아놓고 그 포인터를 저장해놓는다고 한다. 타입 소거 형태라고 하는데, 나중에 알아보자.

