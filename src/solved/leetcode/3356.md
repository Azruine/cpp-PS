# 3356. [Zero Array Transformation II](./3356.cpp)

이거 대체 왜 미디엄이지? 도저히 모르겠어서 레이지 세그로 밀었다.

시간 복잡도는 $O(Q log(N))$인데, 너무 오래 걸린다. 아무리 생각해봐도 이건 정해가 아니다...

그래서 에디토리얼을 읽었다. 발상 하드에 구현이 미디엄이라 미디엄인가보다.

쿼리를 시행할 때, $0$부터 최대 $val_i$까지 줄일 수 있다는 말을 잘 생각해보면 $i$번째 셀에다가 $val_i$를 뺀 결과값이 0보다 작기만 하면 된다는 뜻이다.

따라서 0으로 초기화된 배열을 하나 더 만들고, 거기에다 구간 업데이트를 진행하고 난 뒤 모든 값이 $nums$ 배열의 값보다 커지면 된다.

그러면 쿼리 업데이트와 분석을 어떻게 선형 시간 안에 수행할 수 있을지 생각해봐야 한다.

방법이 진짜 신박한데, 바로 차분 배열과 누적 합을 활용하는 것이다.

쿼리를 $[l, r]$ 에 대해 $val$만큼 수행한다고 해보자. 그러면 차분 배열 $diff$에 대해 다음을 수행한다.

$diff[l] += val, diff[r + 1] -= val$

이렇게 한 뒤에 $diff$ 배열의 누적합 $prefix$를 구해보면 $prefix[l]$부터 $prefix[r]$까지만 $val$만큼 늘어난 것을 확인할 수 있다.

참고로 [공식 에디토리얼](https://leetcode.com/problems/zero-array-transformation-ii/editorial/)에서 이미지까지 포함해서 설명해주니, 시각화를 보고 싶다면 링크를 방문해보는걸 추천한다.

여기까지 왔다면 이제 $k$개의 쿼리를 실행한 결과값을 $O(Q + N)$ 에 구할 수 있다. 이걸 전부 비교해보는 것도 나이브하게 선형에 구현할 수 있다.

이제 **쿼리 개수**를 이분 탐색으로 찾으면 된다.
