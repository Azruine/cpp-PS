# 01080. 행렬

비트 행렬을 뒤집는 문제.

## 그리디 접근

### 정렬 및 중복 제거

편의를 위해 $(i, j)$부터 $(i + 2, j + 2)$까지 뒤집는 것을 $(i, j)$를 뒤집는다고 표현하겠다.

그러면 이 뒤집기 연산은 시행하는 순서가 결과에 영향을 미치지 않는다는 사실을 파악할 수 있다. $(x, y)$와 $(z, u)$를 뒤집는다고 했을 때 영역이 겹치는지, 어느 것을 먼저 시행하는지 여부와 상관없이 오로지 시행했다는 사실만이 결과값에 영향을 끼친다. 각 셀의 결과값은 해당 셀이 뒤집기 영역 내에 몇 번 포함되었는지에 따라 결정되기 때문이다.

그러면 이 뒤집기 연산들을 정렬할 수 있게 된다. 순서가 상관없으니 편한대로 정렬하면 된다. Row major order로 정렬한다고 해보자(책을 읽는 것처럼 좌상단에서 시작해 가로로 훑는 방식이다).

여기에 한 가지 중요한 사실이 추가된다. 같은 셀을 여러 번 뒤집는 것이 결과에 영향을 미칠까?

아까 말했다시피 각 셀의 결과값은 이 셀이 몇 번 뒤집혔는지에 따라 결정된다. 그러면 비트 연산이니 짝수번 뒤집히면 그대로, 홀수번 뒤집히면 반전되는 것이다.

따라서 행렬을 뒤집어서 동일하게 만들 수 있는 연산들이 주어졌을 때, 이를 정렬하고 짝수번 중복되는 연산들을 제거하면 최소값이 될 것이다.

이제 row major order로 행렬을 훑으면서 해당 인덱스의 원소가 다르면 뒤집어보자.

### 베이스 케이스

$[0][0]$에서 $A[0][0] \neq B[0][0]$ 이라면 해당 위치를 뒤집어서 일치시킬 수 있다. **뒤집힌 모든 셀이 아니라** $A[0][0]$과 $B[0][0]$만을 관찰하면 이 두 셀은 반드시 일치한다.

### 일반 케이스

$[i][j]$보다 앞서 살폈던 셀들이 전부 다 일치하게 뒤집혔다고 하자. 그러면 우리가 지금 보고 있는 $A[i][j]$셀에서 뒤집기 연산을 시행하는 것은 앞선 셀들에 영향을 끼치지 않는다.

추가로 현재 Row major order로 셀들을 훑고 있기 때문에 $A[i][j]$셀을 변경할 수 있는 유일한 방법은 $[i][j]$ 위치에서 뒤집기 연산을 시행하는 것 뿐이다.

따라서 뒤쪽 / 앞쪽 연산들을 고려하지 않고 현재 위치에서 셀의 일치 여부에 따라서만 연산을 추가해주면 된다.

### 전역 최적해

[지금까지의 논의](#그리디-접근)를 따라 생성한 해는 정렬이 되어있고, 중복되는 원소가 존재하지 않는다.

이제 그리디로 생성한 해 $G$보다 짧은 해 $S$가 존재한다고 생각해보자. 그러면 위의 정렬 및 중복 제거 문단에서의 논의를 토대로 $S$를 정렬하고 중복을 제거할 수 있다. $S$를 정렬하고 중복을 제거한 해를 $S'$이라고 하자.

이제 $S'$과 $G$의 $LCP$ 를 $X$ 라고 하고, 그 다음에 나오는 연산을 각각 $S'_Y, G_Y$라 하자.

$X$가 $LCP$이므로 $S'_Y \neq G_Y$임이 자명하다.

$S'_Y \lt G_Y$라고 가정하자.

$S'_Y$ 연산을 시행한 위치를 $[i][j]$라 하자. 그러면 $LCP$의 정의에 의해 $G$에서는 $[i][j]$ 셀에서 뒤집기 연산을 시행하지 않았다.

$S'$은 현재 정렬된 상태이고, $[i][j]$에서 뒤집기를 시행하여 $A$와 $B$를 동일하게 변경할 수 있다는 것은 $X$를 시행한 뒤 $A[i][j] \neq B[i][j]$ 라는 것과 동일하다.

그런데 위의 [일반 케이스 단락](#일반-케이스)에서의 논의에 의해, $A[i][j] \neq B[i][j]$ 라면 $G$는 $[i][j]$ 셀에서 뒤집기를 시행한다. 즉 $G$는 $X$ 다음에 $[i][j]$ 셀에서 뒤집기를 시행하여야 하고, 이는 $X$는 $LCP$라는 정의에 모순이다.

이와 비슷한 방식으로 $S'_Y \gt G_Y$일때도 $X$가 $LCP$가 아님을 도출할 수 있다.

따라서 맨 처음 가정인 **$G$보다 짧은 해 $S$가 존재**한다는 가정은 틀렸고, $G$가 전역 최적해임을 알 수 있다.

## 바꾸는지 가능 여부 판단하기

지금까지의 논의에 따라 $A$를 $B$로 변환할 수 있다면 그리디 알고리즘을 통해 해를 구할 수 있는 것을 알았다.

이 명제의 대우를 취하면? 그리디 알고리즘을 통해 해를 구할 수 없다면 $A$를 $B$로 변환할 수 없다.

## 실제 구현

배경 지식 설명은 엄청 장황했지만, 구현은 정말 간단하다.

Row major order로 뒤집기가 가능한 인덱스 내에서 $A$를 훑으면서 $A[i][j] \neq B[i][j]$인 셀이 있다면 $(i, j)$부터 $(i + 2, j + 2)$까지 전부 반전하면 된다.

반전 과정이 끝나고서도 $A \neq B$ 라면 해가 없는, 그러니까 $A$를 $B$로 만들 수 없다는 의미이니 -1을 출력하고 동일하다면 반전 횟수를 출력하면 끝.
