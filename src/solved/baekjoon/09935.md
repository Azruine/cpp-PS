# 09935. 문자열 폭발

너 스택 쓸 줄 아니? 하고 묻는 문제.

리트코드에서도 굉장히 자주 보이는 문제 유형이다.[^1]

[^1]: 실제로 20250211, [오늘 기준 리트코드 데일리](https://leetcode.com/problems/remove-all-occurrences-of-a-substring/?envType=daily-question&envId=2025-02-11)가 이 문제다. 뭐지?

정해진 문자열이 문자열 내에서 발견되는가? 발견되는걸 지우고서 또 나오는걸 지울 수 있는가? 를 생각하면 된다.

좀 더 자세히 살펴보자.

우선 보자마자 바로 떠올릴 수 있는 풀이를 생각해보면 다음과 같다.

1. 문자열을 앞부터 순회한다.
2. 만약 점검중인 문자가 폭발 문자열의 맨 앞 문자와 동일하다면 체크를 수행한다.
3. 문자열이 동일하다면 앞부분 문자열과 뒷부분 문자열을 합친다.
4. 반복한다.

이렇게 수행하면 문제점이 생긴다. 바로 폭발 문자열을 제거한 다음 새로이 생기는 문자열을 확인할 수 없다. 예를 들어보자.

```text
CC44
C4
```

이 입력에서 위 방식대로 순회를 돌리면 중간의 C4는 정상적으로 제거할 수 있다. 문제는 이 다음으로 순회하는 인덱스가 원본 문자열의 4번째, 즉 마지막 4 라는 점이다.

이걸 해결하려면 폭발 문자열의 길이만큼 인덱스를 앞으로 밀어버리던가, 폭발 문자열과 첫 문자가 일치하는 인덱스를 전부 기록해야 할 것 같다.

반대로 발상을 약간 뒤집어서 폭발 문자열의 끝부터 비교한다면? 주어진 문자열에서 폭발을 제거한 뒤에 새로운 폭발 문자열이 생성된다는 것은 다시 생각하면 **현재 탐색중인 인덱스 뒤로 폭발 문자열의 뒷부분이 있다**는 말과 동일하다.

즉 굳이 인덱스를 조작하거나 추가적인 인덱스 저장을 하지 않아도 뒷부분부터 비교를 시작한다면 더 쉽게 문제를 해결할 수 있을 것 같다.

1. 문자열을 앞부터 순회한다.
2. 만약 점검중인 문자가 폭발 문자열의 맨 끝 문자와 동일하다면 점검했던 문자열의 맨 뒤부터 하나씩 비교한다.
3. 폭발 문자열 전체를 찾아냈다면 문자열을 싹 지우고, 다음 인덱스로 넘어간다.

다시 위의 예제를 다시 살펴보자.

```text
CC44
C4
```

3번 인덱스에 도달하면 폭발 문자열의 끝 문자와 동일한 4가 있으니 직전에 넘긴 문자 C를 가져온다. 합치면 C4가 되니 직전에 넘긴 문자 C와 현재 순회중인 4를 합쳐 삭제한다.

다음으로 4번 인덱스에 도달하면 또 4가 있으니 직전에 넘긴 문자를 가져와야 하는데, 우리는 이미 앞에서 C4가 한 번 발견됐음을 알고 있다. 따라서 두 칸 더 앞에 있는 1번 인덱스의 C를 가져와야 한다.

그러면 다시 C4가 완성되니 이것도 지워진다는 것을 알 수 있다.

꽤 괜찮은 접근법인것 같다. 구현을 어떻게 해볼 수 있을까?

우리에게 필요한 것은 넣은 순서를 기억할 수 있고, 맨 마지막에 넣었던 것이 맨 처음으로 나오는 것이다. 바로 스택이다.

1. 원본 문자열을 하나씩 순회하면서 스택에 넣는다.
2. 넣은 문자열이 폭발 문자열의 마지막과 동일한지 확인한다.
3. 동일하다면 문자열을 넣던 스택에서 하나씩 빼면서 폭발 문자열이 실제로 구성되는지 확인한다.
4. 폭발 문자열이 완성되면 스택에서는 완성된 폭발 문자열이 빠진 상태이므로, 다시 원본 문자열 순회로 넘어간다.
5. 문자열이 완성되지 않는다면 제거하면 안되기 때문에 뺐던 문자들을 다시 넣고, 원본 문자열 순회로 넘어간다.

이상을 구현하면 AC를 받을 수 있다.

참고로 C++나 러스트를 쓴다면 그냥 벡터 쓰면 된다. 러스트에는 애초에 스택이 없으니 그렇다 치고, C++에서는 스택이 deque의 랩핑 컨테이너라서 느리다.
